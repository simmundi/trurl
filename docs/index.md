# Trurl ECS

## Entity / Component / System toolkit for the tinkerers

Trurl is a set of libraries for writing simulations in Java. It can be used to write simulations of different
sizes: from mobile games to scientific simulations running on supercomputer nodes (and it has been used for both).

It consists of:

- Store a dataframe implementation optimized for simulations (i.e. mutable)
- an Object-Dataframe-Mapper - mapping dataframe rows to objects and vice versa, so that the simulation logic can be expressed in terms of reading and mutating objects
- framework for writing, chaining and executing in parallel operations that modify the dataframe.
- generic importer / exporter of the dataframe data (imports ORC, CSV and tiled (!); exports ORC, CSV, RDBMS, VisNow)

## Store: a mutable, typed data frame

`Store` instance represents a data frame. It manages a collection of named `Attribute`s of different subtypes: strings
(`StringAttribute`), numbers (`IntAttribute`, `ByteAttribute`... ), booleans, enums etc. If we think of `Store` in
terms of tables or relations, then an attribute represents a single column.

Different implementations of stores can use different mechanisms for storing data under the hood;
the two implementation available out-of-the-box are `Store` (using simple Java arrays)
and `TablesawStore` (using the tablesaw library's `Table` class).

TODO: describe how row references and lists of row references are considered special values

Trurl is not geared towards data analytics, so the store / attribute implementation is very bare, allowing reads and 
writes to single cells (i.e. indexes in a specific attribute) and basic conversion between cell values and strings.

### Mappers - ODM - Object-Dataframe Mapping

While dataframes are state-of-the-art solution for analytics and aggregation,
logic for simulations is usually better expressed within the Object-Oriented
Programming paradigm; indeed the first OO language was Simula, designed expressly
for simulations.

`Mapper<Component>` establishes a link between a `Component` (a DTO-style class storing pieces of data,
like `Person`, `Place`...) and a set of `Attribute`s. The component itself is a POJO (_Plain Old Java Object_),
adhering to some additional, unobtrusive conventions.

Mappers are used not only to save components to a `Store` and load them back, but also configure a store 
by creating the necessary attributes. In a way, components and their mappers serve as schemas for dataframes.

Mappers can be written by hand, but generally are autogenerated by `trurl-generator` (an annotation processor).
A mapper is generated for each class annotated with `@WithMapper`.

Things that should be described in depth in a future release of the docs:
- mappers contain hooks for acting upon changes, but these are meant for low-level code, like building indexes.
- mappers contain functionality for concurrent access (both read and write)
- for some features (like dirty marking) component needs to implement additional interfaces.

### Engine

`Engine` is the central point of Trurl's configuration; the assumption is that each simulation uses a single
engine. The engine contains a single `Store` and a set of mappers. Hence, the engine
instance acts as a data container, enabling usage and persistence of specific components. 

Engine acts as the point of entry for most of the code: it can load and save data to external systems / files.
Finally, an engine manages execution of logic that affects the data - the `System`s.

### Systems

### Glue
